# AI-Powered Procedural Campaign Tools

This project is a suite of Python-based tools designed to procedurally generate vast megadungeons, detailed villages, and tactical battle maps. It integrates **Pygame** for real-time visualization and **Google's Gemini AI** to generate rich, context-aware lore, descriptions, and adventures on the fly.

## Part 1: Current Capabilities & Usage

Currently, these scripts function as powerful **Proof of Concepts (PoC)**. They generate geometry (rooms, corridors, hexes) using algorithms like A* Pathfinding and Cellular Automata, then allow you to "query" specific sectors using Generative AI to create text-based adventure content.

### Prerequisites & Libraries

You will need Python installed (3.8+ recommended).

1.  **Install Dependencies:**
    ```bash
    pip install pygame google-generativeai
    ```

2.  **Get an API Key:**
    *   Get a free API key from [Google AI Studio](https://aistudio.google.com/).
    *   Set it as an environment variable on your system:
        *   **Windows (PowerShell):** `$env:GEMINI_API_KEY="your_key_here"`
        *   **Mac/Linux:** `export GEMINI_API_KEY="your_key_here"`

### The Tools

#### 1. Mega Dungeon (`mega_dungeon.py`)
Generates a massive 150x150 grid-based dungeon. It uses a "fog of war" style viewport rendering system to handle large maps efficiently.

*   **Usage:** `python mega_dungeon.py`
*   **Features:**
    *   **Infinite Scrolling:** Move the camera across a massive map.
    *   **Zooming:** Dynamic cell resizing.
    *   **Sector Generation:** Press `C` to send the currently visible rooms to the AI. It will generate a Markdown file describing the rooms, traps, and monsters based on the specific geometry visible on screen.

#### 2. Mega Village (`mega_village.py`)
A hex-based settlement generator. It places buildings logically (mills near water, inns near roads) and assigns biomes.

*   **Usage:** `python mega_village.py`
*   **Features:**
    *   **Biome Selection:** Choose between Forests, Deserts, Coasts, etc.
    *   **Minimap:** A radar view of the world.
    *   **AI Guide:** Press `G` to have the AI write a "Visitor's Guide" to the village, creating NPCs and rumors based on the specific buildings generated.

#### 3. Tactical Map (`dungeon_adventure_smalll_map.py`)
A focused generator for smaller, battle-map scale encounters.

*   **Usage:** `python dungeon_adventure_smalll_map.py`
*   **Features:**
    *   High-detail rendering with hand-drawn style line wobbling and hatching.
    *   Adventure hook generation based on room layout.

### Controls Reference

| Key | Function |
| :--- | :--- |
| **Arrow Keys** | Move Camera |
| **Shift** | Move Camera Faster |
| **[ and ]** | Zoom In / Out |
| **M** | Toggle Minimap |
| **R** | Regenerate World (New Seed) |
| **S** | Save High-Res Image of Map |
| **C / G** | **Trigger AI Generation** (Context dependent) |

---

# Part 2: The Future Architecture - "Schrödinger's Campaign"

The ultimate goal of this project is to move from a stateless generator to a **Persistent Campaign Database**. This utilizes the concept of "Schrödinger's World building"—details are uncertain until observed by the players, at which point they are generated by AI, fixed in a database, and become permanent canon.

### The Persistence Layer

To achieve this, we will integrate a local database (SQLite) to act as the memory for the Dungeon Master (DM).

#### 1. The "Uncertainty" Workflow
Instead of generating an entire world's history at once, the system works in steps:
1.  **The Skeleton:** The geometry (map) is generated and saved. Room #42 exists, but it is empty.
2.  **The Observation:** The players enter Room #42. The DM clicks the room in the interface.
3.  **The Collapse:** The system checks the DB.
    *   *Is there data?* No.
    *   *Action:* Call Gemini AI. "Generate a description for a 20x20ft room in a goblin dungeon."
    *   *Result:* "A damp larder smelling of rotten meat."
4.  **The Fixing:** This text is saved to the DB linked to `Room_UUID_42`.
5.  **The Recall:** Next time the players visit, the system loads "A damp larder..." from the DB. The AI is not called again.

#### 2. Database Schema Concept

```sql
-- Campaigns Table
CREATE TABLE Campaign (
    id TEXT PRIMARY KEY,
    name TEXT
);

-- Locations (The Geometry)
CREATE TABLE Location (
    id TEXT PRIMARY KEY,
    campaign_id TEXT,
    grid_data JSON, -- Stores the map layout
    is_explored BOOLEAN
);

-- Entities (The Content)
CREATE TABLE Entity (
    id TEXT PRIMARY KEY,
    location_id TEXT,
    type TEXT, -- "NPC", "Room_Desc", "Item"
    name TEXT,
    description TEXT, -- AI Generated & Fixed
    image_path TEXT -- Path to generated portrait
);
```

### The Digital Gaming Table Experience

This architecture is designed to power a physical gaming table (a TV laid flat or a projector setup).

*   **DM Screen (Laptop):** The DM sees the "God View." They can click on NPCs to generate stats, click rooms to generate descriptions, and see hidden traps.
*   **Player Screen (TV Table):** A second Pygame window renders the map with "Fog of War."
*   **Dynamic Visuals:**
    *   When the DM clicks an NPC (e.g., "The Blacksmith"), the system generates a description via Gemini.
    *   Simultaneously, it could prompt an image generator (like Stable Diffusion) to create a portrait based on that description.
    *   This portrait is pushed to the Player Screen instantly.

### Roadmap

1.  **Serialization:** Modify Python classes (`Room`, `Hex`) to export to JSON.
2.  **SQLite Integration:** Create a `CampaignManager` class to handle `INSERT` and `SELECT` operations.
3.  **Click Interaction:** Update the Pygame loop to detect mouse clicks on specific grid cells/hexes to trigger DB lookups.
4.  **Context Window:** Feed previous DB entries back into the AI prompt so the generator "remembers" that the players killed the King last session.
